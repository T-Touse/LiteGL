<!DOCTYPE html>
<html lang="fr">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Test WebGL Renderer</title>
	<style>
		body {
			margin: 0;
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			background: #222;
		}

		canvas {
			border: 1px solid white;
		}
	</style>
</head>

<body>
	<canvas id="canvas"></canvas>

	<script type="module">
		import { Renderer } from '../src/core/renderer.ts';
// ðŸŽ¨ Code GLSL des shaders
const VERTEX_SHADER_SOURCE = `
    attribute vec3 a_position;
    void main() {
        gl_Position = vec4(a_position, 1.0);
    }
`;

const FRAGMENT_SHADER_SOURCE = `
    precision mediump float;
    void main() {
        gl_FragColor = vec4(1.0, 0.5, 0.2, 1.0); // Orange
    }
`;
		function main() {
			// ðŸ“Œ RÃ©cupÃ¨re le canvas et initialise WebGL2
			const canvas = document.getElementById("canvas");
			canvas.width = 500;
			canvas.height = 500;

			const gl = canvas.getContext("webgl2");
			if (!gl) {
				console.error("WebGL2 non supportÃ© !");
				return;
			}

			// ðŸ“Œ Initialise le moteur de rendu
			const renderer = new Renderer(gl);

			// ðŸ“Œ Compile les shaders
			const vertexShader = renderer.createVertexShader(VERTEX_SHADER_SOURCE);
			const fragmentShader = renderer.createFragmentShader(FRAGMENT_SHADER_SOURCE);
			const program = renderer.compileShaderProgram("testProgram", vertexShader, fragmentShader);

			// ðŸ“Œ CrÃ©e un triangle
			const triangle = renderer.createGeometry("triangle", [
				0.0, 0.5, 0.0,  // Sommet haut
				-0.5, -0.5, 0.0,  // Bas gauche
				0.5, -0.5, 0.0   // Bas droit
			]);

			// ðŸ“Œ Affichage
			function render() {
				gl.clearColor(0, 0, 0, 1);
				gl.clear(gl.COLOR_BUFFER_BIT);

				renderer.useShaderProgram(program);
				renderer.setAttribute("a_position", triangle.vertices, 3);
				renderer.draw(triangle);

				requestAnimationFrame(render);
			}

			render(); // ðŸš€ Lance l'affichage
		}

		main();
	</script>
</body>

</html>